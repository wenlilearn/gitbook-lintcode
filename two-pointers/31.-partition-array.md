# 31. Partition Array



{% tabs %}
{% tab title="Problem" %}
Given an array `nums` of integers and an int `k`, partition the array \(i.e move the elements in "nums"\) such that:

* All elements &lt; _k_ are moved to the _left_
* All elements &gt;= _k_ are moved to the _right_

Return the partitioning index, i.e the first index _i_ nums\[_i_\] &gt;= _k_.

#### Example

If nums = `[3,2,2,1]` and `k=2`, a valid answer is `1`.

#### Challenge

Can you partition the array in-place and in O\(n\)?Input test data \(one parameter per line.\)  
{% endtab %}

{% tab title="Solution" %}
#### Partition:

* 小于放左边, 大于等于放右边
* 注意这里的partition和quick sort里面的不太一样, 原因在于对于partition来说, 一定要把这个数组变成两个独立的部分, 左边一定是要&lt;=, 右边一定是要&gt;
* 但是quick sort希望尽可能的均分中间的数, 这样的话performance会好一些
{% endtab %}
{% endtabs %}

